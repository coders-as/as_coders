# 0. 자료구조

## 특징

- 대량의 데이터를 효율적으로 관리할 수 있도록 하는 데이터의 구조
- 데이터 특성에 따라서, 체계적인 데이터 구조화가 필요
- 코드의 효율성, 성능과 밀접한 연관

## 종류

- 지금은 이런 것들이 있다는 것만 알고 넘어갈게요

1. 단순구조
   1. 정수 (int)
   2. 실수 (float)
   3. 문자 (chr)
2. 선형구조 (*이번주 학습 내용* - [그림으로 이해하기](https://visualgo.net/en/list))
   1. 순차리스트 (배열(Array), 리스트(List))
   2. 연결리스트 
      1. 단순연결리스트 (Linked List; LL)
      2. 이중연결리스트 (Doubly Linked List; DLL)
      3. 원형연결리스트 (Circular Linked List; CLL)
   3. 스택 (Stack)
   4. 큐 (Queue)
   5. 덱 (Deque)</font> 
3. 비선형구조
   1. 트리
      1. 이진트리 (Binary Tree)
      2. 일반트리 (Non-Binary Tree)
   2. 그래프
      1. 무향 그래프 ((Undirected) Graph) 
      2. 유향 그래프 (Direct Graph, Digraph)
      3. 가중치 그래프 (Weighted Graph)
4. 파일구조
   1. 순차 파일 (Sequential File)
   2. 직접 파일 (Direct File)
   3. 색인 파일 (색인 순차 파일, Indexed Sequential File) - 순차 파일 + 직접 파일

# 목차

[1. 순차리스트 (배열(Array), 리스트(List))](#1-순차리스트-배열array-리스트list)
- [1-1. 특징](#1-1-특징)
- [1-2. 장점](#1-2-장점)
- [1-3. 단점](#1-3-단점)
- [1-4. 사용하는 경우](#1-4-사용하는-경우)
- [1-5. 파이썬 구현 예제](#1-5-파이썬-구현-예제)

[2. 연결리스트 (Linked List; LL)](#2-연결리스트-linked-list-ll)
- [2-1. 특징](#2-1-특징)
- [2-2. 장점](#2-2-장점)
- [2-3. 단점](#2-3-단점)
- [2-4. 종류](#2-4-종류)
- [2-5. 사용하는 경우](#2-5-사용하는-경우)
- [2-6. 파이썬 구현 예제](#2-6-파이썬-구현-예제)
  - [2-6-1. node 구현](#2-6-1-node-구현)
  - [2-6-2. 연산 구현](#2-6-2-연산-구현)

[3. 스택 (Stack)](#3-스택-stack)
- [3-1. 특징](#3-1-특징)
- [3-2. 장점](#3-2-장점)
- [3-3. 단점](#3-3-단점)
- [3-4. 사용하는 경우](#3-4-사용하는-경우)
- [3-5. 파이썬 구현 예제](#3-5-파이썬-구현-예제)

[4. 큐 (Queue)](#4-큐-queue)
- [4-1. 특징](#4-1-특징)
- [4-2. 장점](#4-2-장점)
- [4-3. 단점](#4-3-단점)
- [4-4. 사용하는 경우](#4-4-사용하는-경우)
- [4-5. 파이썬 구현 예제](#4-5-파이썬-구현-예제)

[5. 덱 (Deque)](#5-덱-deque)
- [5-1. 특징](#5-1-특징)
- [5-2. 장점](#5-2-장점)
- [5-3. 단점](#5-3-단점)
- [5-4. 사용하는 경우](#5-4-사용하는-경우)
- [5-5. 파이썬 구현 예제](#5-5-파이썬-구현-예제)

[99. 정리](#99-정리)
- [99-1. 순차리스트 vs 연결리스트](#99-1-순차리스트-vs-연결리스트)
- [99-2. 스택 vs 큐 vs 덱 ](#99-2-스택-vs-큐-vs-덱)
- [99-3. 성능 (시간 복잡도) 비교](#99-3-성능-시간-복잡도-비교)

# 1. 순차리스트 (배열(Array), 리스트(List))

## 1-1. 특징
[목차로 이동](#목차)

- 논리적인 순서와 물리적인 순서가 같은 구조
- 메모리에 연속적으로 저장됨
![](https://dojang.io/pluginfile.php/9454/mod_page/content/35/unit39-3.png)

## 1-2. 장점
[목차로 이동](#목차)

- 구현이 비교적 간단
- 접근 성능이 좋음 (인덱스를 사용하여 접근 가능)

## 1-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (전체 인덱스에 대한 검색 필요)
- 삽입, 삭제 성능이 좋지 않음 (논리적인 순서와 물리적인 순서가 같기 때문)

        <예시>
        lst = [A, B, C, D, E]
        - B와 C 사이에 값 N 추가 : [A, B, N, C, D, E] 로 변경
          이 때, C ~ E 까지의 값이 한 칸 씩 뒤로 이동
        - 값 C 삭제 : [A, B, D, E] 로 변경.
          이 때, D ~ E 까지의 값이 한 칸 씩 앞으로 이동

![](https://t1.daumcdn.net/cfile/tistory/231DCD385636E3C20F)

- 최초 크기 할당이 필요한 경우
  - 크기 변경이 불가능
  - 데이터 존재 유무와 상관없이 일정 크기의 메모리 공간 점유

## 1-4. 사용하는 경우
[목차로 이동](#목차)

- 랜덤 샘플링 등의 랜덤 액세스가 많을 때

## 1-5. 파이썬 구현 예제
[목차로 이동](#목차)

- 리스트로 구현

```python
lst = [0, 1, 2, 3, 4, 5]
print(lst[3]) # search 3
```

# 2. 연결리스트 (Linked List; LL)

## 2-1. 특징 
[목차로 이동](#목차)

- 각 노드에 저장된 다음 노드의 주소에 의해 연결된 구조
- 노드 = 데이터 + 다음 노드의 주소 (node = data + next)
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist.png)

## 2-2. 장점
[목차로 이동](#목차)

- 길이의 가변성으로 효율적 메모리 사용
- 삽입, 삭제 성능이 좋음 (데이터 재구성 용이)
- 대용량 데이터 처리 적합

## 2-3. 단점 
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 위치까지 순차적으로 순회)
- 메모리를 추가적으로 사용 (다음 노드의 주소를 저장하는 공간이 추가적으로 필요)

## 2-4. 종류
[목차로 이동](#목차)

1. 단순연결리스트 (Linked List; LL)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Single_linked_list.png/400px-Single_linked_list.png)

2. 이중연결리스트 (Doubly Linked List; DLL)
- 양 방향 탐색 가능. 이전 노드에 접근하기 위해 리스트를 순회해야하는 단점을 해소
- 추가적인 메모리 공간이 필요하며, 코드가 복잡해짐.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Doubly_linked_list.png/400px-Doubly_linked_list.png)

3. 원형연결리스트 (Circular Linked List; CLL)
- 한 노드에서 다른 모든 노드로의 접근이 가능. (노드의 삽입, 삭제가 단순해짐.)
- 반복적인 순회에서 연결리스트의 끝을 체크해야할 필요가 없음
- head같은 메타데이터가 필요하지 않고, 이로 인해 시간, 메모리, 코드 모두 이득을 볼 수 있음
- 노드의 삽입, 삭제시 선행 노드의 포인터가 필요하다.
![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Circurlar_linked_list.png/400px-Circurlar_linked_list.png)

## 2-5. 사용하는 경우
[목차로 이동](#목차)

- 목록에서 자주 추가하거나 제거해야하는 데이터로 작업할 때

## 2-6. 파이썬 구현 예제
[목차로 이동](#목차)

- 존재하는 내부 자료구조 없음. 필요하다면 직접 구현 필요

- 하지만, 파이썬에서 링크드 리스트는 의미가 크게 없는 게, 일반적인 리스트가 C++의 STL vector보다도 훨씬 쓰기 간편하며, 어떠한 타입의 데이터도 (심지어 튜플이나 리스트마저) 넣을 수 있고 동적으로 메모리 관리가 되기 때문에, 링크드 리스트의 의미가 크게 퇴색됨.

### 2-6-1. node 구현
[목차로 이동](#목차)
  - Data 필드 : 데이터 저장
  - Link 필드 : 노드의 다음 주소를 저장

```python
# Node class
class Node:
    # Function to initialize the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null
```

### 2-6-2. 연산 구현
[목차로 이동](#목차)
```python
# Linked List class
class LinkedList:
    # Function to initialize the Linked List object
    def __init__(self): 
        self.head = None
```

  1. 삽입 연산 [Insert]

     - 선행자의 링크 필드에 저장된 주소를 삽입할 노드의 링크 필드에 저장
     - 선행자의 링크 필드에 삽입할 노드의 주소를 저장
   
        => 예외 처리 : 선행자를 찾을 수 없는 경우

```python
# This function is in LinkedList class. 
# Inserts a new node after the given prev_node. This method is 
# defined inside LinkedList class shown above */ 
def insert(self, prev_node, new_data): 
  
    # 1. Create new node & 2. Put in the data 
    new_node = Node(new_data)
    
    # 3. check if the given prev_node exists 
    if prev_node is None: 
        new_node.next = self.head
        self.head = new_node
    else:
        # 4. Make next of new Node as next of prev_node
        new_node.next = prev_node.next
    
        # 5. make next of prev_node as new_node 
        prev_node.next = new_node
```

  2. 삭제 연산 [Delete]

     - 삭제할 노드의 링크 필드에 저장된 주소를 선행자의 링크 필드에 저장
     - 삭제할 노드를 삭제한다.
  
        => 예외 처리 : 삭제할 노드를 찾을 수 없는 경우

```python
# This function is in LinkedList class. 
# Given a reference to the head of a list and a key,
# delete the first occurence of key in linked list
def delete(self, key):
        
    # Store head node
    temp = self.head

    # If head node itself holds the key to be deleted
    if (temp is not None):
        if (temp.data == key):
            self.head = temp.next
            temp = None
            return

    # Search for the key to be deleted, keep track of the
    # previous node as we need to change 'prev.next'
    while(temp is not None):
        if temp.data == key:
            break
        prev = temp
        temp = temp.next

    # if key was not present in linked list
    if(temp == None):
        return

    # Unlink the node from linked list
    prev.next = temp.next

    temp = None
```

  - 검색 연산 [Search]

  1. 헤드부터 탐색 시작
  2. 노드의 링크 필드가 Null 일 때까지 탐색
  3. 노드의 데이터 필드가 검색 데이터와 동일하면 탐색 중지
  4. 해당 데이터의 노드 반환
  
        => 검색한 데이터가 리스트에 존재하지 않는 경우
        
        (헤드부터 검색을 하기 때문에 최악의 경우 리스트를 전부 검색해야 함)

```python
# This function is in LinkedList class. 
# This Function checks whether the value x present in the linked list 
def search(self, x):

    # Initialize current to head
    current = self.head

    # loop till current not equal to None
    while current != None:
        if current.data == x:
            return True # data found
            
        current = current.next
        
    return False # Data Not found
```

# 3. 스택 (Stack)

## 3-1. 특징
[목차로 이동](#목차)

- 가장 나중에 쌓은 데이터를 가장 먼저 뺄 수 있는 데이터 구조
- LIFO(Last-In, First-Out)방식을 사용
- 내부 프로세스 구조 함수의 동작 방식으로 사용
![](https://upload.wikimedia.org/wikipedia/commons/b/b4/Lifo_stack.png)

## 3-2. 장점
[목차로 이동](#목차)

- 구조가 단순하고, 구현이 쉬움
- 삽입, 삭제 성능이 좋음 (맨 위의 원소에 대해서만 고려하기 때문)

## 3-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 데이터를 찾을 때까지 수행 필요)
- 맨 위의 원소만 접근 가능

## 3-4. 사용하는 경우
[목차로 이동](#목차)

- 재귀 알고리즘에서 유용하게 사용
- 역추적을 해야할 때 (ex. 문서 작업 시 실행 취소)
- 괄호 검사
- 역순 문자열 만들기
- 후위 표기법으로의 변환

## 3-5. 파이썬 구현 예제
[목차로 이동](#목차)

```python
stack = []
stack.append(1) # 1 
stack.append(2) # 1 - 2 
stack.append(3) # 1 - 2 - 3 
stack.pop()     # 1 - 2     / get 3
stack.pop()     # 1         / get 2
```

# 4. 큐 (Queue)

## 4-1. 특징
[목차로 이동](#목차)

- 먼저 들어간 데이터가 먼저 나가는 데이터 구조
- FIFO(First-In, First-Out : 선입선출) 또는 LILO(Last-In, Last-Out) 방식을 사용
- 연결리스트 (Linked List; LL) 와 비슷
![](https://upload.wikimedia.org/wikipedia/commons/d/d3/Fifo_queue.png)

## 4-2. 장점
[목차로 이동](#목차)

- 삽입, 삭제 성능이 좋음 (양 끝의 원소에 대해서만 고려하기 때문)

## 4-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 데이터를 찾을 때까지 수행 필요)
- 중간에 위치한 데이터로의 접근이 어려움

## 4-4. 사용하는 경우
[목차로 이동](#목차)

- 데이터를 입력된 순서대로 처리해야 할 때
- BFS (너비 우선 탐색) 구현할 때
- 은행 또는 콜센터 대기 순서
- 프로세스 관리

## 4-5. 파이썬 구현 예제
[목차로 이동](#목차)

```python
from queue import Queue

q = Queue()
q.put(1) # 1 
q.put(2) # 1 - 2 
q.put(3) # 1 - 2 - 3 
q.get()  # 2 - 3     / get 1
q.get()  # 3         / get 2
```

# 5. 덱 (Deque)

## 5-1. 특징
[목차로 이동](#목차)

- Double-Ended Queue 의 줄임말
- front와 end에서 삭제와 삽입이 모두 가능
- 이중연결리스트 (Doubly Linked List; DLL) 와 비슷
- 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'이기에 임의 접근 반복자 제공
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb6OjSc%2FbtqwdLZAnhq%2FQ2sUp0jmm4c6z6KuKvnlOK%2Fimg.png)

## 5-2. 장점
[목차로 이동](#목차)

- 삽입, 삭제 성능이 좋음 (양 끝의 원소에 대해서만 고려하기 때문)

## 5-3. 단점
[목차로 이동](#목차)

- 검색 성능이 좋지 않음 (특정 데이터를 찾을 때까지 수행 필요)
- 중간에 위치한 데이터로의 접근이 어려움

## 5-4. 사용하는 경우
[목차로 이동](#목차)

- 앞과 뒤에서 삽입, 삭제가 자주 일어나는 경우
- 데이터의 개수가 가변적일 경우

## 5-5. 파이썬 구현 예제
[목차로 이동](#목차)

```python
from collections import deque

deq = deque()
deq.append(1)     # 1 
deq.append(2)     # 1 - 2 
deq.appendleft(3) # 3 - 1 - 2
deq.pop()         # 3 - 1     / get 2
deq.popleft()     # 1         / get 3
```
# 99. 정리

## 99-1. 순차리스트 vs 연결리스트
[목차로 이동](#목차)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcnu8ag%2FbtqI58Bj81q%2FxWsXOndFYkCuaS3IEBpuO1%2Fimg.png)

## 99-2. 스택 vs 큐 vs 덱 
[목차로 이동](#목차)
- 순차리스트 또는 연결리스트로 구현 (대개는 연결리스트)

![](https://www.nakjunizm.com/2017/02/24/Queue_And_Deque/queue1.png)

## 99-3. 성능 (시간 복잡도) 비교
[목차로 이동](#목차)
- 순차리스트(배열) vs 연결리스트(LL, DLL) vs 스택 vs 큐

| \    | Array                                 | LL                                    | DLL                                   | Stack                                 | Queue                                 |
| ---- | ------------------------------------- | ------------------------------------- | ------------------------------------- | ------------------------------------- | ------------------------------------- |
| 접근 | <font color="green">빠름, O(1)</font> | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            |
| 검색 | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            | 느림, O(n)                            |
| 삽입 | 느림, O(n)                            | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> |
| 삭제 | 느림, O(n)                            | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> | <font color="green">빠름, O(1)</font> |