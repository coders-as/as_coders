# 0. 자료구조 종류 (복습)
[목차로 이동](#목차)

1. 단순구조
   1. 정수 (int)
   2. 실수 (float)
   3. 문자 (chr)
2. 선형구조
   1. 순차리스트 (배열(Array), 리스트(List))
   2. 연결리스트
      1. 단순연결리스트 (Linked List; LL)
      2. 이중연결리스트 (Doubly Linked List; DLL)
      3. 원형연결리스트 (Circular Linked List; CLL)
   3. 스택 (Stack)
   4. 큐 (Queue)
   5. 덱 (Deque)
3. 비선형구조 (*이번주 학습 내용*)
   1. 그래프 - [그림으로 이해하기](https://visualgo.net/en/graphds)
      1. 무향 그래프 ((Undirected) Graph)
      2. 유향 그래프 (Direct Graph, Digraph)
      3. 가중치 그래프 (Weighted Graph)
   2. 트리 - [그림으로 이해하기](https://visualgo.net/en/bst)
      1. 이진 트리 (Binary Tree)
      2. 일반트리 (Non-Binary Tree)
4. 파일구조
   1. 순차 파일 (Sequential File)
   2. 직접 파일 (Direct File)
   3. 색인 파일 (색인 순차 파일, Indexed Sequential File) - 순차 파일 + 직접 파일

![](https://post-phinf.pstatic.net/MjAxODA3MzBfMTU0/MDAxNTMyOTA4MDU1MDEz.0oIEmVrOwXkEXA0BVgEJemJtMIy6DrXgkvpNiO6JZv4g.twDcXbRgLzY_5LtrmLy6MDffWOZXxoOhm1M4gosfFggg.JPEG/mug_obj_201807300847352370.jpg?type=w1080)

# 목차

- [0. 자료구조 종류 (복습)](#0-자료구조-종류-복습)
- [목차](#목차)
- [1. 그래프](#1-그래프)
  - [1-1. 개요](#1-1-개요)
  - [1-2. 용어](#1-2-용어)
  - [1-3. 활용](#1-3-활용)
  - [1-4. 종류](#1-4-종류)
    - [1-4-1. 무향 그래프 ((Undirected) Graph)](#1-4-1-무향-그래프-undirected-graph)
    - [1-4-2. 유향 그래프 (Direct Graph, Digraph)](#1-4-2-유향-그래프-direct-graph-digraph)
    - [1-4-3. 가중치 그래프 (Weighted Graph)](#1-4-3-가중치-그래프-weighted-graph)
  - [1-5. 파이썬 구현 예제](#1-5-파이썬-구현-예제)
- [2. 트리](#2-트리)
  - [2-1. 개요](#2-1-개요)
  - [2-2. 용어](#2-2-용어)
  - [2-3. 트리의 필요조건](#2-3-트리의-필요조건)
  - [2-4. 종류](#2-4-종류)
    - [2-4-1. 이진 트리 (Binary Tree), M-원 트리 (M-Way Tree)](#2-4-1-이진-트리-binary-tree-m-원-트리-m-way-tree)
    - [2-4-2. 탐색 트리 (Search Tree)](#2-4-2-탐색-트리-search-tree)
    - [2-4-3. 균형 트리 (Balanced Tree)](#2-4-3-균형-트리-balanced-tree)
    - [2-4-4. 신장 트리 (Spanning Tree)](#2-4-4-신장-트리-spanning-tree)
  - [2-5. 주요 트리](#2-5-주요-트리)
    - [2-5-1. AVL 트리 (Adelson-Velsky and Landis Tree)](#2-5-1-avl-트리-adelson-velsky-and-landis-tree)
    - [2-5-2. Red-Black 트리 (RB Tree)](#2-5-2-red-black-트리-rb-tree)
    - [2-5-3. 2-3 트리, 2-3-4 트리](#2-5-3-2-3-트리-2-3-4-트리)
    - [2-5-4. B트리(B-Tree), B+ 트리, B* 트리](#2-5-4-b트리b-tree-b-트리-b-트리)
  - [2-6. 파이썬 구현 예제 - BST](#2-6-파이썬-구현-예제---bst)
    - [2-6-1. node 구현](#2-6-1-node-구현)
    - [2-6-2. 연산 구현](#2-6-2-연산-구현)
- [99. 정리](#99-정리)

# 1. 그래프

## 1-1. 개요
[목차로 이동](#목차)

- 일부 객체들의 쌍들이 서로 연관된 객체의 집합을 이루는 구조
- 그래프에 대한 표현식
  - 그래프 G = (V, E)
    - V(G) : 그래프 꼭짓점들의 집합.
    - E(G) : 그래프 변들의 집합.

![](https://slideplayer.com/8833046/26/images/slide_1.jpg)

## 1-2. 용어
[목차로 이동](#목차)

- 기본 용어
  - 꼭짓점(정점, Vertex, Node; V) : 그래프에서의 객체
  - 변(간선, Edge, Link, Line; E) : 그래프에서 객체들 사이의 연결
- 관련 용어
  - 차수(Degree) : 한 꼭짓점에 이어져 있는 변의 수
  - 인접(Adjacent) : 두 개의 꼭짓점 사이에 변이 존재할 때, 이 두 꼭짓점은 인접한다고 정의
  - 경로(path) : 변들의 순서열
    - 단순 경로(Simple Path) : 같은 꼭짓점을 중복해서 거치지 않는 경로
  - 순환(Cycle) : 단순 경로의 시작 꼭짓점과 종료 꼭짓점이 동일한 상태
  - 연결됨(connected) : 두 꼭지점 사이에 경로가 존재하는 상태

## 1-3. 활용
[목차로 이동](#목차)

- 비선형 구조로 임의의 관계를 표현한 데이터 문제를 해결
- 컴퓨터 통신망, 도로망, 사람들 사이의 관계 등 복잡한 응용 문제를 효과적으로 표현할 수 있는 자료구조

## 1-4. 종류
[목차로 이동](#목차)

### 1-4-1. 무향 그래프 ((Undirected) Graph)

- 일반적인 그래프를 표시
- 변에 방향성이 없어서 연결된 꼭짓점들의 순서가 정해지지 않은 그래프
- (V1, V2)와 (V2, V1)는 같은 변을 나타냄

### 1-4-2. 유향 그래프 (Direct Graph, Digraph)

- 변에 방향성이 있어서 연결된 꼭짓점들의 순서가 정해진 그래프
- (V1, V2)와 (V2, V1)는 서로 다른 간선을 나타냄
- 활용 : 먹이그물, 게임 트리 등

### 1-4-3. 가중치 그래프 (Weighted Graph)

- 꼭짓점과 꼭짓점 사이를 잇는 변(간선)에 가중치(비용)가 주어진 그래프
- 네트워크(Network) : 가중 그래프 중의 유향 그래프

## 1-5. 파이썬 구현 예제
[목차로 이동](#목차)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuEUXH%2FbtqLYNN1d0N%2FBzS13GPvM2Qv2eHBZ9Fbv0%2Fimg.png)

1. 인접 행렬 기반 그래프
   - 각 정점간의 가중치나 간선의 유무를 행렬로 표현
   - 무향 그래프의 경우 전치행렬이 되어도 값이 같음
    ```python
    graph = [
        [0, 1, 1, 1],
        [1, 0, 1, 0],
        [1, 1, 0, 1],
        [1, 0, 1, 0]
    ]
    ```

2. 인접 리스트 기반 그래프
   - 연결 리스트의 집합을 사용하여 구현
   - 파이썬에서는 딕셔너리 자료형에 리스트를 넣어 쉽게 구현 가능
    ```python
    graph = {
        'A' : ['B', 'C', 'D'],
        'B' : ['A'],
        'C' : ['A'],
        'D' : ['A']
    }
    ```

# 2. 트리

## 2-1. 개요
[목차로 이동](#목차)

- 방향성이 있는 비순환 그래프의 한 종류
- 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조
- 서로 다른 자식을 가지는 재사용되지 않는 노드들의 집합
  - 하나의 뿌리 노드와 0개 이상의 자식 노드를 가지며 이것이 반복적으로 정의되는 자료구조

![](https://w.namu.la/s/606aecc8b8a27d42129f3e13c6db9a871a4566cd88c123689585256281efb5dde5b35f4e516572f0e5f0e419f0ae2be3aedf7a9c8dbb1756d1bf635a48da67ec0be1df6d252a96f49c1893112c4068b5004973e6d233453da934c2557e5e9514cf3b576a8a4b743f3ffa0039b7e9e3b5)

![](https://cdn.filepicker.io/api/file/wQN09RtgSPey2HE6Xoc0)

## 2-2. 용어
[목차로 이동](#목차)

![](http://www.ktword.co.kr/img_data/4726_1.jpg)

- 기본 용어
  - 노드(Node) : 트리를 구성하는 기본 원소, 트리에서의 꼭짓점(정점, Vertex)
  - 가지(관계, Branch) : 트리에서의 변(간선, Edge, Link, Line)
  - 뿌리, 잎, 가지 노드
    - 뿌리 노드(루트 노드, Root Node, Root) : 트리에서 부모가 없는 최상위 노드
      - 트리의 시작점 (트리 자료구조의 진입 노드)
      - 예) 뿌리 노드 : A
    - 잎 노드(단말 노드, 리프 노드, Leaf Node, Terminal Node) : 트리의 맨 마지막 노드
      - 예) 잎 노드 : F,I,J,K,L,M,N
    - 가지 노드(Branch Node) : 트리에서 잎 노드를 제외한 나머지 노드
      - 예) 가지 노드 : A,B,C,D,E,G,H
  - 부모, 자식, 형제 노드
    - 부모 노드(Parent Node) : 뿌리 노드 방향으로 직접 연결된 노드
      - 예) 부모 노드 : (B, E) 관계에서 B
    - 자식 노드(Child Node) : 뿌리 노드 반대방향으로 직접 연결된 노드
      - 예) 자식 노드 : (B, E) 관계에서 E
    - 형제 노드(Siblings Node) : 같은 부모 노드를 갖는 노드들
      - 예) 형제 노드 : 부모 노드 B를 기준으로 D, E, F

- 관련 용어
  - 부트리(Subtree) : 큰 트리에 속하는 작은 트리
  - 차수(간선수, Degree) : 각 노드가 지닌 가지의 수
    - 자식 노드, 부트리(subtree)의 갯수
    - 예) A의 차수 = 2, B의 차수 = 3, C의 차수 = 2
  - 트리의 차수(Degree of Tree) : 트리의 최대 차수 = max[deg1, deg2, ..., degn]
  - 경로(Path) : 한 노드에서 다른 한 노드에 이르는 길 사이에 있는 노드들의 순서
  - 길이(Length) : 출발 노드에서 도착 노드까지 거치는 노드의 개수
    - 예) E에서 G까지의 길이 : 4
  - 깊이(Depth) : 뿌리 노드에서 어떤 노드까지의 경로 길이
    - 예) D의 경로 깊이 : 2
  - 높이(Height) : 뿌리 노드까지 가장 긴 경로의 길이
    - 예) 깊이 : 4
  - 레벨(Level) : 뿌리 노드(Level = 1)부터 노드까지 연결된 링크 수의 합
    - 예) A의 레벨 : 1 ; B,C의 레벨 : 2 ; D,E,F,G,H의 레벨 : 3
  - 크기(Size) : 노드의 개수
    - 예) 크기 : 14
  - 너비(Width) : 가장 많은 노드를 갖고 있는 레벨의 크기

## 2-3. 트리의 필요조건
[목차로 이동](#목차)

1. 모든 노드가 시작되는 특정한 뿌리 노드(root node)가 존재한다.
2. 노드와 노드 사이의 가지가 하나만 존재한다.
3. 각 노드들 사이에 순환이 존재하지 않는다.
4. 뿌리 노드를 제외한 다른 노드들도 자신을 뿌리 노드로 하는 트리여야 한다.

## 2-4. 종류
[목차로 이동](#목차)

### 2-4-1. 이진 트리 (Binary Tree), M-원 트리 (M-Way Tree)

1. 이진 트리 (Binary Tree)
   - 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리
   - 자식 노드 : 왼쪽 자식 노드(Left Child Node), 오른쪽 자식 노드(Right Child Node)
2. M-원 트리 (M-Way Tree)
   - 각각의 노드가 m개 이하의 자식 노드를 가질 수 있는 트리
   - 각 노드가 자식을 많이 갖게 하여 트리의 높이를 줄이기 위함

### 2-4-2. 탐색 트리 (Search Tree)

  - 데이터 세트 내에서 특정 키를 찾는 데 사용되는 트리
  - 키 (Key)
    - 탐색하고자 하는 데이터의 지정된 부분과 비교되는 데이터
    - 모든 키들은 유일함 (노드의 값에 중복이 없음)
  - 이진 탐색 트리 (BST, Binary Search Tree) : 이진 트리 + 탐색 트리
  - 이진 탐색 트리의 조건
    2. 왼쪽 자식 노드는 부모 노드보다 작음
    3. 오른쪽 자식 노드는 부모 노드보다 큼
    4. 부트리(Subtree)도 위의 조건을 충족
  - 이진 탐색 예제
  ![](https://w.namu.la/s/86d0064cf511a86f2b9aa24a322305c37680361cc6379c9aa5e582afae026d60e551cfe944257877ee9450316d9126dab412106160bbe2a52f94ff3c73c7c5369609c0b18bb39c2dfb54b3544eeacee87f1c8321e379b12ca713d418b55d8d4d2d6c699a7816991164e691f32bdf1d66)

### 2-4-3. 균형 트리 (Balanced Tree)

- 트리 사용의 핵심인 빠른 접근을 극대화하기 위한 트리
- 조건 (1, 2 모두 만족시 균형 트리)
  1. 자식 노드들에서 시작된 부트리(Subtree)들의 높이 차가 제약 범위 안에 들어옴
  2. 자식 노드들에서 시작된 부트리(Subtree)들이 모두 균형 트리임
- 트리가 한 쪽으로 치우친 경우, 탐색의 시간 복잡도가 O(n)이기 때문에 탐색의 시간 복잡도를 O(log n) 으로 만들어줌

### 2-4-4. 신장 트리 (Spanning Tree)

- 임의의 그래프에 대한 부분 그래프 중에서 모든 정점과 최소로 연결된 부분 그래프
- 그래프에 사이클이 형성이 되면 안됨

## 2-5. 주요 트리
[목차로 이동](#목차)

### 2-5-1. AVL 트리 (Adelson-Velsky and Landis Tree)
  - 삽입/삭제 연산시 Balance Factor(BF)* 가 일정 값 이상(보통 2) 혹은 이하(-2)로 바뀐 노드를 기준으로 그 부트리(Subtree)들의 위치를 회전하여 전체의 균형을 맞추는 이진 탐색 트리
  - 회전의 종류 : LL, LR, RL, RR
  - 자료구조를 만든 세 명의 이름 앞 글자를 따서 명명
  - 장점 : N개의 노드가 존재한다면 항상 O(logN)을 유지
  - 단점 : 새로운 노드의 삽입과 삭제는 오히려 성능을 떨어뜨림
  - *Balance Factor(BF) : 왼쪽 부트리(Subtree)의 높이에서 오른쪽 부트리(Subtree)의 높이를 뺀 것
    - 두 부트리(Subtree)의 높이가 같거나 잎새노드일 때의 BF : 0
    - empty tree의 BF : -1

### 2-5-2. Red-Black 트리 (RB Tree)
  - AVL 트리의 단점인 삽입/삭제 시의 전체 트리 재구성을 줄이기 위해 제안된 이진 탐색 트리
  - 각 노드에 색깔을 저장하는 공간을 추가하여 색깔을 기준으로 균형을 맞추는 이진 탐색 트리
  - 더 적은 회전이 수행되므로 AVL 트리보다 빠른 삽입 및 제거 작업을 제공
  - 각 노드에 높이(정수)를 저장하는 AVL 트리와 달리 노드 당 1비트의 정보(색깔)만 저장
  - 조건
    1. 모든 노드는 빨간색, 검은색 둘 중 하나
    2. 뿌리 노드는 검은색
    3. 모든 리프 노드들(NIL)은 블랙
    4. 레드 노드의 자식노드 양쪽은 언제나 모두 블랙 (레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 됨)
    5. 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있음

### 2-5-3. 2-3 트리, 2-3-4 트리
  - AVL 트리의 단점인 삽입/삭제 시의 전체 트리 재구성을 줄이기 위해 제안된 M-원 균형 탐색 트리
  - 2-3 Tree : 한 노드에 들어갈 수 있는 데이터 수가 최대 2개, 자식 노드가 최대 3개인 균형 트리
  - 2-3-4 Tree : 한 노드에 들어갈 수 있는 데이터 수가 최대 3개, 자식 노드가 최대 4개인 균형 트리

### 2-5-4. B트리(B-Tree), B+ 트리, B* 트리
  - B트리(B-Tree) : 이진 탐색 트리, 2-3 Tree 등을 일반화하여 한 노드에 여러개의 데이터를 담을 수 있는 M-원 균형 탐색 트리
  - 조건
    1. 뿌리와 잎 노드를 제외한 트리의 각 노드는 최소 [m/2]개의 부트리(Subtree)를 가짐 ([] : 가우스 기호)
    2. 뿌리는 최소한 2개의 부트리(Subtree)를 가짐
    3. 노드 내의 데이터는 반드시 정렬된 상태
    4. 잎 노드는 모두 같은 레벨에 존재
  - B+ 트리
    - 잎 노드 간에 연결 리스트를 구성한 B트리
    - 순차 처리를 할 때는 키값을 비교하지 않고 차례로 다음 데이터에 접근
  - B* 트리
    - 노드의 약 2/3이상이 채워지는 B트리
    - 노드가 꽉 차면 분리하지 않고, 키와 포인터를 재배치하여 다른 형제 노드로 옮김
    - 삽입/삭제 시 발생하는 노드 분리를 줄이려고 고안됨

###

## 2-6. 파이썬 구현 예제 - BST

### 2-6-1. node 구현
[목차로 이동](#목차)
  - Data 필드 : 데이터 저장
  - Link 필드 : 노드의 다음 주소를 저장

```python
# Node class
class Node:
    # Constructor to create a new node
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
```

### 2-6-2. 연산 구현
[목차로 이동](#목차)

1. 검색 연산 [Search]
```python
# A utility function to search a given key in BST
def search(root,key):

    # Base Cases: root is null or key is present at root
    if root is None or root.val == key:
        return root

    # Key is greater than root's key
    if root.val < key:
        return search(root.right,key)

    # Key is smaller than root's key
    return search(root.left,key)
```

2. 삽입 연산 [Insert]
```python
# A utility function to insert a
# new node with given key in BST
def insert(node, key):

    # If the tree is empty,
    # return a new node
    if node is None:
        return Node(key)

    # Otherwise recur down the tree
    if key < node.key:
        node.left = insert(node.left, key)
    else:
        node.right = insert(node.right, key)

    # return the (unchanged) node pointer
    return node
```

3. 삭제 연산 [Delete]
```python
# Given a binary search tree
# and a key, this function
# delete the key and returns the new root
def deleteNode(root, key):

    # Base Case
    if root is None:
        return root

    # Recursive calls for ancestors of
    # node to be deleted
    if key < root.key:
        root.left = deleteNode(root.left, key)
        return root

    elif(key > root.key):
        root.right = deleteNode(root.right, key)
        return root

    # We reach here when root is the node
    # to be deleted.

    # If root node is a leaf node

    if root.left is None and root.right is None:
          return None

    # If one of the children is empty

    if root.left is None:
        temp = root.right
        root = None
        return temp

    elif root.right is None:
        temp = root.left
        root = None
        return temp

    # If both children exist

    succParent = root

    # Find Successor

    succ = root.right

    while succ.left != None:
        succParent = succ
        succ = succ.left

    # Delete successor.Since successor
    # is always left child of its parent
    # we can safely make successor's right
    # right child as left of its parent.
    # If there is no succ, then assign
    # succ->right to succParent->right
    if succParent != root:
        succParent.left = succ.right
    else:
        succParent.right = succ.right

    # Copy Successor Data to root

    root.key = succ.key

    return root
```

# 99. 정리

![](https://gmlwjd9405.github.io/images/data-structure-graph/graph-vs-tree.png)
