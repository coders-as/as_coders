# 0. DFS, BFS 요약
[목차로 이동](#목차)

![](https://ww.namu.la/s/1fe9246903b78fae07577b243a0b22791e02cb39640d5cbaae10d9849343b4ea6f162a9a677a5892fbf7819abd4ef7221ebd3608849cfb66793411fb5e643951e15e85878fb7692c53895549f3ca09bdbfa07655909d194e6658ca66a48be536)

![](https://media.vlpt.us/images/513sojin/post/fac1b4e5-c8c5-4d05-9e98-0bb3fb0534e7/bfs.png)

# 목차

- [0. DFS, BFS 요약](#0-dfs--bfs---)
- [목차](#--)
- [1. 트리 순회 (Tree Traversal)](#1--------tree-traversal-)
  * [1-1. 깊이 우선 순회](#1-1---------)
    + [1-1-1. 중위순회](#1-1-1-----)
    + [1-1-2. 후위순회](#1-1-2-----)
    + [1-1-3. 전위순회](#1-1-3-----)
  * [1-2. 레벨 순서 순회](#1-2---------)
- [2. 깊이 우선 탐색 (Depth-First Search, DFS)](#2-----------depth-first-search--dfs-)
  * [2-1. 개요](#2-1---)
  * [2-2. 장점](#2-2---)
  * [2-3. 단점](#2-3---)
  * [2-4. 구현 - stack](#2-4------stack)
- [3. 너비 우선 탐색 (Breath-First Search, BFS)](#3-----------breath-first-search--bfs-)
  * [3-1. 개요](#3-1---)
  * [3-2. 장점](#3-2---)
  * [3-3. 단점](#3-3---)
  * [3-4. 구현 - queue](#3-4------queue)
- [4. 파이썬 구현 예제](#4----------)
  * [4-1. 트리 구현](#4-1------)
  * [4-2. 깊이 우선 탐색 (Depth-First Search, DFS)](#4-2-----------depth-first-search--dfs-)
  * [4-3. 너비 우선 탐색 (Breath-First Search, BFS)](#4-3-----------breath-first-search--bfs-)

# 1. 트리 순회 (Tree Traversal)

-  트리 구조에서 각각의 노드를 정확히 한 번만, 체계적인 방법으로 방문하는 과정

## 1-1. 깊이 우선 순회
[목차로 이동](#목차)

![](https://t1.daumcdn.net/cfile/tistory/236A5537570E432F2E)

### 1-1-1. 중위순회
```python
def inorder(node):
    if node.left is not null:
        inorder(node.left)
    print(node.value)
    if node.right is not null:
        inorder(node.right)
```

### 1-1-2. 후위순회
```python
def postorder(node):
    if node.left is not null:
        postorder(node.left)
    if node.right is not null:
        postorder(node.right)
    print(node.value)
```

### 1-1-3. 전위순회
```python
def preorder(node):
    print(node.value)
    if node.left is not null:
        preorder(node.left)
    if node.right is not null:
        preorder(node.right)
  ```

## 1-2. 레벨 순서 순회

![](https://blog.kakaocdn.net/dn/p6ctB/btqAY7bzV17/PyaNv2dOKaBZkCUjsoQkR0/img.png)

```python
from collections import deque

def levelorder(root):
    q = deque()
    q.append(root)
    while q:
        node = q.pop()
        visit(node)
        if node.left is not null:
            q.append(node.left)
        if node.right is not null:
            q.append(node.right)
```

# 2. 깊이 우선 탐색 (Depth-First Search, DFS)
[목차로 이동](#목차)

## 2-1. 개요

- 트리 순회의 깊이 우선 순회 방식
  - 트리나 그래프에서 한 루트로 최대한 깊숙히 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 맹목적 탐색방법의 일종
- 퇴각 검색 (백트래킹, Backtracking)에 사용
  - 한정 조건을 가진 문제를 풀려는 전략 (해를 얻을 때까지 모든 가능성을 시도)
  - 해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아가는 기법

## 2-2. 장점

- 현 경로상의 노드들만을 기억하기 때문에 저장 공간의 수요가 비교적 적음
- 목표 노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있음
- 조건에 맞지 않을 때 공통 상위를 가지는 아래 리프 노드들을 한방에 잘라 내 버리는게 가능

## 2-3. 단점
- 스택 오버플로우를 유의 (메모리 구조 스택의 한계 메모리를 초과)
- 해가 없는 경로에 깊이 빠질 가능성 존재
  - 실제로는 미리 지정한 임의 깊이까지만 탐색하고 목표 노드를 발견하지 못하면 다음 경로를 따라 탐색 - 깊이 제한(Depth Bound)
- 얻어진 해가 최단 경로가 된다는 보장이 없음
  - 목표에 이르는 경로가 다수인 문제에 대해 깊이우선탐색은 해에 다다르면 탐색을 끝내버리기 때문

## 2-4. 구현 - stack
1. 첫 번째 위치를 스택에 삽입
2. 맨 위에서 하나 빼낸 후, 그 위치에서 갈 수 있는 경로를 스택에 모두 대입
3. 원하는 값을 찾을 때까지 2번을 반복

# 3. 너비 우선 탐색 (Breath-First Search, BFS)
[목차로 이동](#목차)

## 3-1. 개요

- 트리 순회의 레벨 순서 순회 방식
  - 현재 정점에서 갈 수 있는 위치부터 끝까지 탐색해나가는 맹목적 탐색방법의 일종
- "케빈 베이컨의 6단계" 게임 등에 활용
  - 여러 갈래 중 무한에 가까운 길이를 가지는 경로가 존재하고 탐색 목표가 다른 경로에 존재하는 경우

## 3-2. 장점

- 출발노드에서 목표노드까지의 최단 길이 경로를 보장

## 3-3. 단점
- 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 하게 됨
- 해가 존재하지 않는다면
  - 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패
  - 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못함

## 3-4. 구현 - queue
1. 첫 번째 위치를 큐에 삽입
2. 큐에 넣었던 값을 빼낸 후, 그 위치에서 갈 수 있는 경로를 큐에 모두 삽입
3. 원하는 값을 찾을 때까지 2번을 반복

# 4. 파이썬 구현 예제
[목차로 이동](#목차)

![](https://itholic.github.io/assets/images/2019/02/07/python-graph/graph.png)

## 4-1. 트리 구현

```python
tree = {
    'A': ['B'],
    'B': ['A', 'C', 'H'],
    'C': ['B', 'D'],
    'D': ['C', 'E', 'G'],
    'E': ['D', 'F'],
    'F': ['E'],
    'G': ['D'],
    'H': ['B', 'I', 'J', 'M'],
    'I': ['H'],
    'J': ['H', 'K'],
    'K': ['J', 'L'],
    'L': ['K'],
    'M': ['H']
}
```

## 4-2. 깊이 우선 탐색 (Depth-First Search, DFS)

```python
def dfs(tree, start_node):
  visit = set()
  stack = list()

  stack.append(start_node)

  while stack:
    node = stack.pop()
    if node not in visit:
      visit.append(node)
      stack.extend(graph[node])

  return visit
```

## 4-3. 너비 우선 탐색 (Breath-First Search, BFS)

```python
from queue import Queue

def bfs(tree, start_node):
  visit = set()
  q = Queue()

  q.put(start_node)

  while q.qsize() > 0:
    node = q.get()
    if node not in visit:
      visit.add(node)
      for nextNode in graph[node]:
        q.put(nextNode)

  return visit
```
